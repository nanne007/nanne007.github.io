<!DOCTYPE html>
<html lang="en-us">

<head>
  
    <title>尾递归和延续传递 | Give me five</title>
    <meta name="DC.Title" content="尾递归和延续传递">
  

  
    <meta name="DC.Date" content="2013/11/23">
  

  
    <meta name="DC.Creator" content="Jiafeng Cao">
  

  
    <meta name="DC.Language" content="en">
  

  
    <meta name="DC.Description" content="本文源自于 Daniel P.Friedman 的一篇讲稿 - 编程语言研究在程序员教育中所扮演的角色 。
 上一周，我和几个大学朋友做了一次简单的 workshop，分享的是尾递归和延续传递。
从递归说起 首先来看看一个递归形式的 sum 程序：
function sum(n) { if (0 == n) { return 0; } else { return n &#43; sum(n - 1); } }  等同的尾递归形式如下：
function sum(n, acc) { if (0 == n) { return acc; } else { return sum(n - 1, acc &#43; n); } }  由于 nodejs 没有尾递归优化，当 n 超过调用栈的最大值时， 上述两种形式的代码都会产生 RangeError: Maximum call stack size exceeded 的错误。">
  

  
    <meta name="DC.Identifier" content="/posts/tailcall-and-cps/">
  

  

  

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="../../css/style.css" />
  <link rel="stylesheet" href="../../css/fonts.css" />
</head>

    <a class="skip-main" href="#main">Skip to main content</a>
        <nav>
      <h1> Give me five </h1>
      <div>
      
      
      
      
        <a href="../../" title="Home">home</a>
      
      
        <a href="../../posts/" title="Posts">posts</a>
      
      
        <a href="../../notes/" title="Notes">notes</a>
      

      
      
        <a href="../../index.xml" title="RSS">rss</a>
      
      </div>
    </ul>
  </nav>




<main id="main">
<header>
    
        <h1>尾递归和延续传递</h1>
    

    
        
            Jiafeng Cao
        
         2013/11/23 
    

    
</header>

<article>


<blockquote>
<p>本文源自于 <a href="http://www.cs.indiana.edu/~dfried/">Daniel P.Friedman</a> 的一篇讲稿 - <a href="http://www.cs.indiana.edu/~dfried/dfried/dfried/mex.pdf">编程语言研究在程序员教育中所扮演的角色</a> 。</p>
</blockquote>

<p>上一周，我和几个大学朋友做了一次简单的 workshop，分享的是<a href="http://en.wikipedia.org/wiki/Tail_call">尾递归</a>和<a href="http://en.wikipedia.org/wiki/Continuation-passing_style">延续传递</a>。</p>

<h2 id="从递归说起">从递归说起</h2>

<p>首先来看看一个递归形式的 <code>sum</code> 程序：</p>
<div class="highlight"><pre style="color:#fff;background-color:#111;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript">  <span style="color:#fb660a;font-weight:bold">function</span> sum(n) {
    <span style="color:#fb660a;font-weight:bold">if</span> (<span style="color:#0086f7;font-weight:bold">0</span> == n) {
      <span style="color:#fb660a;font-weight:bold">return</span> <span style="color:#0086f7;font-weight:bold">0</span>;
    } <span style="color:#fb660a;font-weight:bold">else</span> {
      <span style="color:#fb660a;font-weight:bold">return</span> n + sum(n - <span style="color:#0086f7;font-weight:bold">1</span>);
    }
  }
</code></pre></div>
<p>等同的尾递归形式如下：</p>
<div class="highlight"><pre style="color:#fff;background-color:#111;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript">  <span style="color:#fb660a;font-weight:bold">function</span> sum(n, acc) {
    <span style="color:#fb660a;font-weight:bold">if</span> (<span style="color:#0086f7;font-weight:bold">0</span> == n) {
      <span style="color:#fb660a;font-weight:bold">return</span> acc;
    } <span style="color:#fb660a;font-weight:bold">else</span> {
      <span style="color:#fb660a;font-weight:bold">return</span> sum(n - <span style="color:#0086f7;font-weight:bold">1</span>, acc + n);
    }
  }
</code></pre></div>
<p>由于 nodejs 没有尾递归优化，当 <code>n</code> 超过调用栈的最大值时，
上述两种形式的代码都会产生 <code>RangeError: Maximum call stack size exceeded</code> 的错误。</p>

<p>当然，这个求和函数是可以直接使用求和公式计算的，
但，举这个例子的目的不在于此，毕竟很多问题是没有公式可循的。</p>

<h2 id="重写递归程序">重写递归程序</h2>

<p>我们可以用寄存器形式来重写这个递归代码。</p>
<div class="highlight"><pre style="color:#fff;background-color:#111;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript">{
  <span style="color:#fb660a;font-weight:bold">var</span> n = <span style="color:#fb660a;font-weight:bold">null</span>;
  <span style="color:#fb660a;font-weight:bold">var</span> acc = <span style="color:#fb660a;font-weight:bold">null</span>;
}

<span style="color:#fb660a;font-weight:bold">function</span> sum() {
  <span style="color:#fb660a;font-weight:bold">if</span> (<span style="color:#0086f7;font-weight:bold">0</span> == n) {
    <span style="color:#fb660a;font-weight:bold">return</span> acc;
  } <span style="color:#fb660a;font-weight:bold">else</span> {
    acc = acc + n;
    n = n - <span style="color:#0086f7;font-weight:bold">1</span>;
    sum();
  }
}

{
  n = <span style="color:#0086f7;font-weight:bold">100000</span>;
  acc = <span style="color:#0086f7;font-weight:bold">0</span>;
  sum();
}
</code></pre></div>
<p>代码中添加了两个模拟寄存器的变量 <code>n</code> 和 <code>acc</code> ，
移除了函数的所有参数，通过（保存）“寄存器”将其传递给下一次的函数调用。
这段代码依旧存在上面的调用栈溢出的问题，但已经越来越接近了。</p>

<p>现在，把这个过程放大，以便有一个更清晰的认识。</p>
<div class="highlight"><pre style="color:#fff;background-color:#111;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript">{
  <span style="color:#fb660a;font-weight:bold">var</span> n = <span style="color:#fb660a;font-weight:bold">null</span>;
  <span style="color:#fb660a;font-weight:bold">var</span> acc = <span style="color:#fb660a;font-weight:bold">null</span>;
}

<span style="color:#fb660a;font-weight:bold">function</span> sum() {
  <span style="color:#fb660a;font-weight:bold">if</span> (<span style="color:#0086f7;font-weight:bold">0</span> == n) {
    <span style="color:#fb660a;font-weight:bold">return</span> acc;
  } <span style="color:#fb660a;font-weight:bold">else</span> {
    acc = acc + n;
    n = n - <span style="color:#0086f7;font-weight:bold">1</span>;
    <span style="color:#fb660a;font-weight:bold">return</span> sum;
  }
}

{
  n = <span style="color:#0086f7;font-weight:bold">100000</span>;
  acc = <span style="color:#0086f7;font-weight:bold">0</span>;
  sum();
}
</code></pre></div>
<p>函数 <code>sum</code> 在运行一次后挂起，再次调用时，从上次的“寄存器状态”重启运行。</p>

<p>认识到这一点之后，重新思考整个运行过程，就可以构造出下面的代码：</p>
<div class="highlight"><pre style="color:#fff;background-color:#111;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript">{
  <span style="color:#fb660a;font-weight:bold">var</span> n = <span style="color:#fb660a;font-weight:bold">null</span>;
  <span style="color:#fb660a;font-weight:bold">var</span> acc = <span style="color:#fb660a;font-weight:bold">null</span>;
}

<span style="color:#fb660a;font-weight:bold">function</span> sum() {
  <span style="color:#fb660a;font-weight:bold">if</span> (<span style="color:#0086f7;font-weight:bold">0</span> == n) {
    <span style="color:#fb660a;font-weight:bold">return</span> <span style="color:#fb660a;font-weight:bold">false</span>;
  } <span style="color:#fb660a;font-weight:bold">else</span> {
    acc = acc + n;
    n = n - <span style="color:#0086f7;font-weight:bold">1</span>;
    <span style="color:#fb660a;font-weight:bold">return</span> sum;
  }
}

<span style="color:#fb660a;font-weight:bold">function</span> run() {
  <span style="color:#fb660a;font-weight:bold">while</span> (sum()) { <span style="color:#080;background-color:#0f140f;font-style:italic">/*do no operation*/</span> }
  <span style="color:#fb660a;font-weight:bold">return</span> acc;
}

{
  n = <span style="color:#0086f7;font-weight:bold">100000</span>;
  acc = <span style="color:#0086f7;font-weight:bold">0</span>;
  run();
}
</code></pre></div>
<p>至此，完成了尾递归到迭代的转换（彻头彻尾的循环代码）。</p>

<h2 id="接下来">接下来&hellip;</h2>

<p>但接下来还能够做些什么呢？
下面我们引入另一个寄存器 <code>action</code> ，消除函数中的 <code>return</code> 。</p>
<div class="highlight"><pre style="color:#fff;background-color:#111;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript">{
  <span style="color:#fb660a;font-weight:bold">var</span> n = <span style="color:#fb660a;font-weight:bold">null</span>;
  <span style="color:#fb660a;font-weight:bold">var</span> acc = <span style="color:#fb660a;font-weight:bold">null</span>;
  <span style="color:#fb660a;font-weight:bold">var</span> action = <span style="color:#fb660a;font-weight:bold">null</span>;
}

<span style="color:#fb660a;font-weight:bold">function</span> sum() {
  <span style="color:#fb660a;font-weight:bold">if</span> (<span style="color:#0086f7;font-weight:bold">0</span> == n) {
    action = <span style="color:#fb660a;font-weight:bold">false</span>;
  } <span style="color:#fb660a;font-weight:bold">else</span> {
    acc = acc + n;
    n = n - <span style="color:#0086f7;font-weight:bold">1</span>;
    action = sum;
  }
}

<span style="color:#fb660a;font-weight:bold">function</span> run() {
  <span style="color:#fb660a;font-weight:bold">while</span> (action) { <span style="color:#080;background-color:#0f140f;font-style:italic">/*perform the action*/</span>  action(); }
  <span style="color:#fb660a;font-weight:bold">return</span> acc;
}

{
  n = <span style="color:#0086f7;font-weight:bold">100000</span>;
  acc = <span style="color:#0086f7;font-weight:bold">0</span>;
  action = sum;
  run();
}
</code></pre></div>
<p>在每一个返回点，将 <code>sum</code> 返回的值写入寄存器 <code>action</code> ，这样，函数既不依赖传入的参数，也不依赖返回的值。</p>

<h2 id="一个小结">一个小结</h2>

<p>现在，已经完成了尾递归到循环的转换。但这种转换本不应该由语言的使用者去处理。
选择一个可以处理此类问题的编程语言吧，不要让让语言创造者的错误成为你的噩梦。</p>

<h2 id="延续传递风格-continuation-passing-style">延续传递风格（Continuation Passing Style）</h2>

<p>对于大多数的递归程序，把他们转换成尾递归形式并不是那么容易。
但这不是问题，接下来的部分会展示一个通用的方法，而不依赖宿主语言的特有功能。
据此方法得到的尾递归形式的代码具有 CPS(Continuation Passing Style) 性质。</p>

<h3 id="cps-形式的-sum">CPS 形式的 <code>sum</code></h3>

<p>再来看看最初的这个 sum 函数：</p>
<div class="highlight"><pre style="color:#fff;background-color:#111;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#fb660a;font-weight:bold">function</span> sum(n) {
  <span style="color:#fb660a;font-weight:bold">if</span> (<span style="color:#0086f7;font-weight:bold">0</span> == n) {
    <span style="color:#fb660a;font-weight:bold">return</span> <span style="color:#0086f7;font-weight:bold">0</span>;
  } <span style="color:#fb660a;font-weight:bold">else</span> {
    <span style="color:#fb660a;font-weight:bold">return</span> n + sum(n - <span style="color:#0086f7;font-weight:bold">1</span>);
  }
}
</code></pre></div>
<p>我们要做的第一件事情就是给每个函数额外添加一个参数，这个参数代表了函数返回后要做的事情。</p>
<div class="highlight"><pre style="color:#fff;background-color:#111;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#fb660a;font-weight:bold">function</span> identity(income) { <span style="color:#fb660a;font-weight:bold">return</span> income; }

<span style="color:#fb660a;font-weight:bold">function</span> sum(n, cont) {
  cur = (<span style="color:#0086f7;font-weight:bold">0</span> == n) ? <span style="color:#0086f7;font-weight:bold">0</span> : (n + sum(n - <span style="color:#0086f7;font-weight:bold">1</span>, cont));
  <span style="color:#fb660a;font-weight:bold">return</span> cont(cur);
}

sum(<span style="color:#0086f7;font-weight:bold">100000</span>, identity);
</code></pre></div>
<p>把 <code>cont</code> 的计算向 if 语句推进，得到：</p>
<div class="highlight"><pre style="color:#fff;background-color:#111;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#fb660a;font-weight:bold">function</span> identity(income) { <span style="color:#fb660a;font-weight:bold">return</span> income; }

<span style="color:#fb660a;font-weight:bold">function</span> sum(n, cont) {
  <span style="color:#fb660a;font-weight:bold">if</span> (<span style="color:#0086f7;font-weight:bold">0</span> == n) {
    <span style="color:#fb660a;font-weight:bold">return</span> cont(<span style="color:#0086f7;font-weight:bold">0</span>);
  } <span style="color:#fb660a;font-weight:bold">else</span> {
    <span style="color:#fb660a;font-weight:bold">return</span> cont(n + sum(n - <span style="color:#0086f7;font-weight:bold">1</span>, cont));
  }
}

sum(<span style="color:#0086f7;font-weight:bold">100000</span>, identity);
</code></pre></div>
<p>继续推进，则需要处理最后这个包含了递归调用的表达式 <code>sum(n - 1, cont)</code> ：</p>
<div class="highlight"><pre style="color:#fff;background-color:#111;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#fb660a;font-weight:bold">function</span> identity(income) { <span style="color:#fb660a;font-weight:bold">return</span> income; }

<span style="color:#fb660a;font-weight:bold">function</span> sum(n, cont) {
  <span style="color:#fb660a;font-weight:bold">if</span> (<span style="color:#0086f7;font-weight:bold">0</span> == n) {
    <span style="color:#fb660a;font-weight:bold">return</span> cont(<span style="color:#0086f7;font-weight:bold">0</span>);
  } <span style="color:#fb660a;font-weight:bold">else</span> {
    <span style="color:#fb660a;font-weight:bold">return</span> sum(n - <span style="color:#0086f7;font-weight:bold">1</span>, <span style="color:#fb660a;font-weight:bold">function</span>(acc) { <span style="color:#fb660a;font-weight:bold">return</span> cont(n + acc); });
  }
}
</code></pre></div>
<p>通过创建一个延续（continuation）来负责接下来的事情。
（这里，接下来的事情就是：将 <code>n</code> 累加到 <code>acc</code> ，然后调用外层的延续）
现在，这个递归函数已经被转换成 <strong>接近尾递归</strong> 的调用。
（之所以称为接近尾递归，是因为匿名函数中包含了自由变量，引用了当前调用栈的 <code>n</code> 和 <code>cont</code> ）</p>

<p>接下来要做的事情就是对自由变量的解引用。
我们知道，本例中，需要解引用的是匿名函数 <code>function(acc) { cont(n + acc) }</code> 中的变量 <code>n</code> 和 <code>cont</code> 。
在 javascript 中，可以用下列的方式实现
（<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let">let binding</a> 还有待被接受 ）：</p>
<div class="highlight"><pre style="color:#fff;background-color:#111;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript">(<span style="color:#fb660a;font-weight:bold">function</span>(n, cont) {
  <span style="color:#fb660a;font-weight:bold">return</span> <span style="color:#fb660a;font-weight:bold">function</span>(acc) { <span style="color:#fb660a;font-weight:bold">return</span> cont(n + acc);
})(n, cont);
</code></pre></div>
<p>从而得到：</p>
<div class="highlight"><pre style="color:#fff;background-color:#111;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#fb660a;font-weight:bold">function</span> identity(income) { <span style="color:#fb660a;font-weight:bold">return</span> income; }

<span style="color:#fb660a;font-weight:bold">function</span> sum(n, cont) {
  <span style="color:#fb660a;font-weight:bold">if</span> (<span style="color:#0086f7;font-weight:bold">0</span> == n) {
    <span style="color:#fb660a;font-weight:bold">return</span> cont(<span style="color:#0086f7;font-weight:bold">0</span>);
  } <span style="color:#fb660a;font-weight:bold">else</span> {
    <span style="color:#fb660a;font-weight:bold">return</span> sum(n - <span style="color:#0086f7;font-weight:bold">1</span>, (<span style="color:#fb660a;font-weight:bold">function</span>(n, cont) {
      <span style="color:#fb660a;font-weight:bold">return</span> <span style="color:#fb660a;font-weight:bold">function</span>(acc) { <span style="color:#fb660a;font-weight:bold">return</span> cont(n + acc); };
    })(n, cont));
  }
}
</code></pre></div>
<p>这是一个完整的具有延续传递风格的尾递归程序。</p>

<h3 id="cps-形式到寄存器形式的转换">CPS 形式到寄存器形式的转换</h3>

<p>在没有尾递归优化的编程语言（如 C、Java、Ruby）中，上述的的代码依旧会产生调用栈溢出的错误。
不过，仿照文章前半部分，可以很轻易的把它变成迭代形式。</p>
<div class="highlight"><pre style="color:#fff;background-color:#111;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript">{
  <span style="color:#fb660a;font-weight:bold">var</span> n = <span style="color:#fb660a;font-weight:bold">null</span>;
  <span style="color:#fb660a;font-weight:bold">var</span> acc = <span style="color:#fb660a;font-weight:bold">null</span>;
  <span style="color:#fb660a;font-weight:bold">var</span> action = <span style="color:#fb660a;font-weight:bold">null</span>;
  <span style="color:#fb660a;font-weight:bold">var</span> cont = <span style="color:#fb660a;font-weight:bold">null</span>;
}

<span style="color:#fb660a;font-weight:bold">function</span> identity() { action = <span style="color:#fb660a;font-weight:bold">false</span>; }

<span style="color:#fb660a;font-weight:bold">function</span> sum() {
  <span style="color:#fb660a;font-weight:bold">if</span> (<span style="color:#0086f7;font-weight:bold">0</span> == n) {
    acc = <span style="color:#0086f7;font-weight:bold">0</span>;
    action = cont;
  } <span style="color:#fb660a;font-weight:bold">else</span> {
    cont = (<span style="color:#fb660a;font-weight:bold">function</span>(n, cont) {
      <span style="color:#fb660a;font-weight:bold">return</span> <span style="color:#fb660a;font-weight:bold">function</span>() {
        acc = n + acc;
        action = cont;
      };
    })(n, cont);
    n = n - <span style="color:#0086f7;font-weight:bold">1</span>;
    action = sum;
  }
}

<span style="color:#fb660a;font-weight:bold">function</span> run() {
  <span style="color:#fb660a;font-weight:bold">while</span> (action) { action(); }
  <span style="color:#fb660a;font-weight:bold">return</span> acc;
}

{
  n = <span style="color:#0086f7;font-weight:bold">100000</span>;
  acc = <span style="color:#0086f7;font-weight:bold">0</span>;
  cont = identity;
  action = sum;
  run();
}
</code></pre></div>
</article>
</main>

    <footer>
    <hr>
      
  <link rel="stylesheet" href="../../css/vs.min.css">
  <script src="../../js/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>


  <script>
    
    let elements = document.getElementsByClassName("highlight");
    for (let element_id = 0; element_id < elements.length; element_id++) {
      const element = elements[element_id];
      
      element.firstChild.setAttribute("style", "");
      
      let language = element.firstChild.firstChild.getAttribute("data-lang");
      if (language !== null) {
          element.firstChild.firstChild.setAttribute("class", language);
      }
    }
  </script>

  <script>
    const code = document.querySelectorAll("code");
    [...code].forEach(el => el.textContent = el.textContent.replace(/^\n/,''));
  </script>

      <p>
        Last updated Sep 08 2020
      </p>
      <p>
        
      </p>
      <br>
    </footer>
  </body>
</html>

