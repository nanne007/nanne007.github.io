<!DOCTYPE html>
<html lang="en-us">

<head>
  
    <title>Elixir 问题总结 | Give me five</title>
    <meta name="DC.Title" content="Elixir 问题总结">
  

  
    <meta name="DC.Date" content="2016/06/20">
  

  
    <meta name="DC.Creator" content="Jiafeng Cao">
  

  
    <meta name="DC.Language" content="en">
  

  
    <meta name="DC.Description" content="Elixir 中的 try-catch Elixir 有三种异常类型：
 :error, 由 Kernel.raise 产生 :throw, 由 Kernel.throw/1 产生 :exit, 由 Kernel.exit/1 产生  try-catch 中的子句中，
try do do_something_that_may_fail(some_arg) rescue x in [ArgumentError] -&amp;gt; IO.puts &amp;#34;Invalid argument given&amp;#34; catch class, value -&amp;gt; IO.puts &amp;#34;#{class}caught #{value}&amp;#34; else value -&amp;gt; IO.puts &amp;#34;Success! The result was #{value}&amp;#34; after IO.puts &amp;#34;This is printed regardless if it failed or succeed&amp;#34; end  rescue 部分只能用来处理 :error 类型， 常见的包括： RuntimeError、ArgumentError、ErlangError，也可通过 Kernel.defexception/1 自定义类型。 catch 部分对这三种类型都可以处理，类型通过class 进行绑定（未指定 class 时，默认是 :throw）。 else 部分在未出错的情况下执行。 after 部分无论什么情况都会执行。  Erlang 中的 try-catch Erlang 有两个表达式来处理，一个是 catch，另一个是 try-catch。">
  

  
    <meta name="DC.Identifier" content="/posts/about-elixir/">
  

  

  

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="../../css/style.css" />
  <link rel="stylesheet" href="../../css/fonts.css" />
</head>

    <a class="skip-main" href="#main">Skip to main content</a>
        <nav>
      <h1> Give me five </h1>
      <div>
      
      
      
      
        <a href="../../" title="主页">主页</a>
      
      
        <a href="../../posts/" title="文章">文章</a>
      
      
        <a href="../../notes/" title="笔记">笔记</a>
      
      
        <a href="../../projects/" title="项目">项目</a>
      

      
      
        <a href="../../index.xml" title="订阅">订阅</a>
      
      </div>
    </ul>
  </nav>




<main id="main">
<header>
    
        <h1>Elixir 问题总结</h1>
    

    
        
            Jiafeng Cao
        
         2016/06/20 
    

    
</header>

<article>


<h3 id="elixir-中的-try-catch">Elixir 中的 try-catch</h3>

<p>Elixir  有三种异常类型：</p>

<ul>
<li><code>:error</code>, 由 <code>Kernel.raise</code> 产生</li>
<li><code>:throw</code>, 由 <code>Kernel.throw/1</code> 产生</li>
<li><code>:exit</code>, 由 <code>Kernel.exit/1</code> 产生</li>
</ul>

<p>try-catch 中的子句中，</p>
<div class="highlight"><pre style="color:#fff;background-color:#111;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-elixir" data-lang="elixir">try do
   do_something_that_may_fail(some_arg)
rescue
  x in [ArgumentError] -&gt;
    IO.puts <span style="color:#0086d2">&#34;Invalid argument given&#34;</span>
catch
  class, value -&gt;
    IO.puts <span style="color:#0086d2">&#34;</span><span style="color:#0086d2">#{</span>class<span style="color:#0086d2">}</span><span style="color:#0086d2"> caught </span><span style="color:#0086d2">#{</span>value<span style="color:#0086d2">}</span><span style="color:#0086d2">&#34;</span>
else
  value -&gt;
    IO.puts <span style="color:#0086d2">&#34;Success! The result was </span><span style="color:#0086d2">#{</span>value<span style="color:#0086d2">}</span><span style="color:#0086d2">&#34;</span>
after
  IO.puts <span style="color:#0086d2">&#34;This is printed regardless if it failed or succeed&#34;</span>
end</code></pre></div>
<ul>
<li><code>rescue</code> 部分只能用来处理 <code>:error</code> 类型，
常见的包括： <code>RuntimeError</code>、<code>ArgumentError</code>、<code>ErlangError</code>，也可通过 <code>Kernel.defexception/1</code> 自定义类型。</li>
<li><code>catch</code> 部分对这三种类型都可以处理，类型通过<code>class</code> 进行绑定（未指定 class 时，默认是 <code>:throw</code>）。</li>
<li><code>else</code> 部分在未出错的情况下执行。</li>
<li><code>after</code> 部分无论什么情况都会执行。</li>
</ul>

<h3 id="erlang-中的-try-catch">Erlang 中的 try-catch</h3>

<p>Erlang 有两个表达式来处理，一个是 <code>catch</code>，另一个是 <code>try-catch</code>。</p>

<h4 id="catch-me">Catch me</h4>

<p><code>catch</code> 将表达式中产生的三种异常转换成信息。</p>

<ul>
<li><code>error</code> =&gt; {&lsquo;EXIT&rsquo;, {Reason, Stacktrace}}</li>
<li><code>exit(Term)</code> =&gt; {&lsquo;EXIT&rsquo;, Term}</li>
<li><code>throw(Term)</code> =&gt; Term</li>
</ul>
<div class="highlight"><pre style="color:#fff;background-color:#111;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-erlang" data-lang="erlang"><span style="color:#080;background-color:#0f140f;font-style:italic">%%% catch EXPR
</span><span style="color:#080;background-color:#0f140f;font-style:italic"></span><span style="color:#fb660a;font-weight:bold">catch</span> <span style="color:#0086f7;font-weight:bold">1</span>+a. <span style="color:#080;background-color:#0f140f;font-style:italic">% =&gt; {&#39;EXIT&#39;,{badarith,[...]}}
</span><span style="color:#080;background-color:#0f140f;font-style:italic"></span><span style="color:#fb660a;font-weight:bold">catch</span> exit(invalidargs) <span style="color:#080;background-color:#0f140f;font-style:italic">%=&gt; {&#39;EXIT&#39;, invalidargs}
</span><span style="color:#080;background-color:#0f140f;font-style:italic"></span><span style="color:#fb660a;font-weight:bold">catch</span> <span style="color:#ff0086;font-weight:bold">throw</span>(<span style="color:#0086f7;font-weight:bold">1</span>). % =&gt; <span style="color:#0086f7;font-weight:bold">1</span></code></pre></div>
<h4 id="catch-me-and-distinguish-me">Catch me and distinguish me</h4>

<p><code>try-catch</code> 是增强版的 <code>catch</code>， 可以拿到异常的类型。</p>
<div class="highlight"><pre style="color:#fff;background-color:#111;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-erlang" data-lang="erlang"><span style="color:#080;background-color:#0f140f;font-style:italic">%%% try-catch
</span><span style="color:#080;background-color:#0f140f;font-style:italic"></span><span style="color:#fb660a;font-weight:bold">try</span> <span style="color:#fb660a">EXPR</span>
<span style="color:#fb660a;font-weight:bold">catch</span>
  <span style="color:#fb660a">CLASS</span>:<span style="color:#fb660a">EXCEPTION</span> -&gt;
    %% do something with the exception.
<span style="color:#fb660a;font-weight:bold">end</span></code></pre></div>
<p>可以看出，Elixir 和 Erlang 中的 try-catch 基本是相对应的，Erlang 中的 <code>catch</code> 没有对应的 Elixir 版本。
这是可以理解的，毕竟用到 <code>catch</code> 的地方一般都可以用 <code>try-catch</code> 代替。</p>

<h3 id="进程退出">进程退出</h3>

<p>总结一下 <strong>进程退出(proccess exiting)</strong> 这个话题。</p>

<p>如下我站在进程 A 的的视角解释它会以哪一种方式狗带。</p>

<h4 id="进程内部">进程内部</h4>

<p>从进程自身来说：</p>

<ul>
<li>第一种是自然死亡：进程执行完（或者显式的调用 <code>exit(:normal)</code>），留下 <code>:normal</code> 消息。</li>
<li>其次就是自杀：进程调用 <code>exit(:kill)</code> 方法结束自己的生命，留下 <code>:kill</code> 消息。</li>
<li>最后是生病死亡：进程在工作的过程中，不小心出错了，比如：<code>ArgumentError</code>、<code>ArithmeticError</code>，留下的消息就是这些错误信息。
（死前也可以显示地调用 <code>exit(other_reason)</code> 来说明自己死去的原因）。</li>
</ul>

<h4 id="进程外部">进程外部</h4>

<p>外部环境也可以通过 <code>Process.exit/2</code> 方法来杀死进程 A：</p>

<ul>
<li><code>exit(pid, :normal)</code> 对 A 来说是无效的，毕竟任何外部因素无法使一个人自然死亡。
（如果调用这个方法的是 A 自己，就和从进程内部显示调用 <code>exit(:normal)</code> 的效果一样）</li>
<li><code>exit(pid, :kill)</code> 能够成功杀死 A，A 会留下消息 <code>killed</code>。</li>
<li><code>exit(pid, other_reason)</code> 同样也会将病传给了 A，致其死亡，A 留下消息 <code>other_reason</code>。</li>
</ul>

<p>内部和外部导致进程 A 死亡的情况差不多，要么自然死亡，要么染病死亡，在要么被人暗杀或者自杀。</p>

<h4 id="进程防御">进程防御</h4>

<p>对于外部环境的暗杀，进程 A 是有自己的防御措施的。
A 通过 <code>Process.flag(:trap_exit, true)</code> 给自己加上 <code>trap_exit</code> 防御后，</p>

<ul>
<li>受到外部的 <code>:normal</code> 攻击时，A 不但不会受到任何伤害，还会记录该攻击的具体情况（<code>{:EXIT, _from_who, :normal}</code>）。</li>
<li>受到外部的 <code>:kill</code> 攻击时，A 防御失败，最终死亡。</li>
<li>受到外部的 <code>other_reason</code> 攻击时，A 防御成功，也会记录该攻击的情况（<code>{:EXIT, _from_who, _other_reason}</code>）。</li>
</ul>

<p>以上是我理解的进程退出。有任何遗漏或者错误，欢迎讨论。</p>

<p>那么问题来了， <code>exit(:kill)</code> 和 <code>Process.exit(pid, :kill)</code> 有什么区别？
想清楚这个问题， <strong>Process Exiting</strong> 就尘埃落定了，具体可参见 <a href="https://github.com/erlang/otp/pull/854">This PR in Erlang/OTP</a>。</p>

<h3 id="macro-使用">Macro 使用</h3>

<p>第一次用 Elixir 写代码，拿 <a href="https://github.com/lerencao/stockfighter">stockfighter</a> 练手。
期间遇到一个编译错误，总是提示 <code>__struct__ is not defined</code>，
排查了一会，发现是 <code>use HTTPoison.Base</code> 引起的。</p>

<p>在它的 <code>__using__</code> 中发现了这样一行代码： <code>defoverridable Module.definitions_in(__MODULE__)</code>。
我的 module 中使用了 <code>defstruct</code>，
所以这行代码会使得 module 中 <code>__struct__</code> 方法（用 <code>defstruct</code> 时会编译出该方法）被惰性定义，
用 <code>%__MODULE__{}</code> 作 pattern matching 会出现上面提到的错误。</p>

<p>起初我很自然地认为这行代码是罪魁祸首，就给 httpoison 提了一个 <a href="https://github.com/edgurgel/httpoison/pull/110">PR</a>。
后来再审视的时候，突然想起来，Elixir 中，macro 的使用顺序是很重要的。
在 using module 之前使用 <code>defstruct</code>，<code>__struct__</code> 会被 overridable，
但如果是在之后的话，<code>defoverridable Module.definitions_in(__MODULE__)</code> 这行代码在执行时，
<code>__struct__</code> 还不存在，就不会被 overridable 了。
试了试，发现问题确实出在这里。</p>
<div class="highlight"><pre style="color:#fff;background-color:#111;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-elixir" data-lang="elixir">defmodule FooBar do
  defmacro __using__(_) do
    quote do
      defoverridable Module.definitions_in(__MODULE__)
      Module.definitions_in(__MODULE__) |&gt; IO.inspect
    end
  end
end

defmodule MyModule do
  use FooBar <span style="color:#080;background-color:#0f140f;font-style:italic"># it should be used first</span>
  defstruct <span style="color:#0086d2">bar</span>: nil
  def foo(%__MODULE__{<span style="color:#0086d2">bar</span>: bar}), <span style="color:#0086d2">do</span>: bar
end</code></pre></div>
<h3 id="plug-源码">Plug 源码</h3>

<p><a href="https://github.com/elixir-lang/plug">Plug</a></p>

<p>从 <code>Plug</code> 开始，<code>Plug</code> 本身是一个 <code>Application</code>，里面定义了 <code>start</code> 回调方法。
同时，它还是一个 *behaviour*，用于实现各种各样的 Web 模块。</p>

<p>作为 application 时，<code>Plug</code> 依托于 <code>Plug.Supervisor</code>，它做了两件事情：</p>

<ul>
<li>启动 <code>Plug.Upload</code>，用于管理文件上传。</li>
<li>另外定义了 <code>Plug.Key</code> ets。</li>
</ul>

<h4 id="作为-behaviour">作为 <code>Behaviour</code></h4>

<p><code>Plug.Conn</code>: <em>unset</em> &mdash;&gt; (<em>set</em> | <em>file</em>) &mdash;&gt; <em>sent</em> | <em>chunked</em></p>

<ul>
<li><code>put_status</code>: &mdash;&gt; <em>sent</em></li>
<li><code>resp</code>: unsent(<em>unset</em> | <em>set</em>) &mdash;&gt; <em>set</em></li>
<li><code>send_resp</code>: <em>set</em> &ndash;&gt; <em>set</em> =&gt; <code>run_before_send</code> =&gt; <code>adapter.send_resp</code> &ndash;&gt; <em>sent</em></li>
<li><code>send_file</code>: unsent([<code>unset</code>, <code>set</code>]) &ndash;&gt; <em>file</em> =&gt; <code>run_before_send</code> =&gt; <code>adapter.send_file</code> &ndash;&gt; <em>sent</em></li>
<li><code>send_chunked</code>: unsent &ndash;&gt; <em>chunked</em> =&gt; <code>run_before_send</code> =&gt; <code>adapter.send_chunked</code> &ndash;&gt; <em>chunked</em>
<code>chunk</code>: <em>chunked</em> =&gt; <code>adapter.chunk</code></li>
</ul>

</article>
</main>

    <footer> 
    <hr>
      
  <link rel="stylesheet" href="../../css/vs.min.css">
  <script src="../../js/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>


  <script>
    
    let elements = document.getElementsByClassName("highlight");
    for (let element_id = 0; element_id < elements.length; element_id++) {
      const element = elements[element_id];
      
      element.firstChild.setAttribute("style", "");
      
      let language = element.firstChild.firstChild.getAttribute("data-lang");
      if (language !== null) {
          element.firstChild.firstChild.setAttribute("class", language);
      }
    }
  </script>

  <script>
    const code = document.querySelectorAll("code");
    [...code].forEach(el => el.textContent = el.textContent.replace(/^\n/,''));
  </script>

      <p>
        Last updated Jul 07 2019
      </p>
      <p>
        
      </p>
      <br>
    </footer>
  </body>
</html>

